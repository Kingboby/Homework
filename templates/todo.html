<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>To-Do</title>
<style>
  :root{
    --bg:#f5f5f5; --card:#fff; --accent:#007BFF; --muted:#f0f0f0; --danger:#dc3545;
  }
  html,body{height:100%; margin:0; font-family:Arial,Helvetica,sans-serif; background:var(--bg);}
  .todo-container{width:90%; max-width:420px; margin:30px auto; background:var(--card);
    padding:18px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.08);}
  h1{text-align:center;margin:0 0 16px;color:#333}
  .input-row{display:flex; gap:8px; margin-bottom:16px}
  #taskInput{flex:1;padding:12px;border-radius:8px;border:1px solid #ccc;font-size:15px}
  .add-btn{width:50px;border-radius:8px;border:none;background:var(--accent);color:#fff;font-size:22px;cursor:pointer}
  .add-btn:active{transform:scale(.98)}
  ul#taskList{list-style:none;padding:0;margin:0}
  .task-wrap{position:relative; overflow:visible}
  .task{
    background:var(--muted); margin-bottom:10px; border-radius:10px;
    display:flex; align-items:center; justify-content:space-between;
    padding:12px 14px; box-sizing:border-box; user-select:none;
    transition:transform 180ms ease, box-shadow 120ms ease;
    touch-action: pan-y;
  }
  .task.dragging{opacity:0.5; box-shadow:0 8px 20px rgba(0,0,0,0.08)}
  .task .text{flex:1; padding-right:10px; word-break:break-word}
  .handle{
    width:34px; height:34px; display:inline-flex; align-items:center; justify-content:center;
    border-radius:8px; background:rgba(0,0,0,0.06); cursor:grab; margin-left:8px;
    user-select:none; -webkit-user-select:none;
  }
  .handle:active{cursor:grabbing}
  .delete-btn{
    position:absolute; right:10px; top:50%; transform:translateY(-50%);
    background:var(--danger); color:#fff; border:none; padding:8px 12px;
    border-radius:8px; display:none; z-index:5; font-weight:bold; cursor:pointer;
  }
  .delete-show .delete-btn{display:block}
  .swiped { transform: translateX(-110px); }
  @media (max-width:480px){
    .handle{width:42px;height:42px;font-size:18px}
    .add-btn{width:56px}
  }
</style>
</head>
<body>
  <div class="todo-container">
    <h1>To-Do</h1>
    <div class="input-row">
      <input id="taskInput" type="text" placeholder="Enter a new task...">
      <button id="addTaskBtn" class="add-btn">+</button>
    </div>

    <ul id="taskList" aria-live="polite"></ul>
  </div>

<script>
/* ======= setup ======= */
const taskInput = document.getElementById('taskInput');
const addTaskBtn = document.getElementById('addTaskBtn');
const taskList = document.getElementById('taskList');

addTaskBtn.addEventListener('click', addTask);
taskInput.addEventListener('keydown', e => { if(e.key==='Enter'){ e.preventDefault(); addTask(); } });

function addTask(){
  const text = taskInput.value.trim();
  if(!text) return;
  const liWrap = document.createElement('li'); liWrap.className = 'task-wrap';
  const li = document.createElement('div'); li.className = 'task';
  li.setAttribute('draggable','false'); // item itself not draggable; handle will be
  li.innerHTML = `<div class="text">${escapeHtml(text)}</div>
                  <div class="handle" aria-hidden="true" draggable="true">☰</div>`;
  const delBtn = document.createElement('button');
  delBtn.className = 'delete-btn';
  delBtn.textContent = 'Delete';
  // delete click: remove wrapper; stop propagation so other handlers don't hide it first
  delBtn.addEventListener('click', (ev) => { ev.stopPropagation(); liWrap.remove(); });
  liWrap.appendChild(li);
  liWrap.appendChild(delBtn);

  attachItemEvents(liWrap, li, delBtn);
  taskList.appendChild(liWrap);
  taskInput.value = '';
  taskInput.focus();
}
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/* ======= HTML5 drag + get insertion ======= */
let draggedItem = null; // actual .task element being dragged

// when dragging over list, compute insertion based on pointer Y
taskList.addEventListener('dragover', e => {
  e.preventDefault();
  const after = getDragAfterElement(taskList, e.clientY);
  if(!draggedItem) return;
  if(after == null){
    taskList.appendChild(draggedItem.parentElement);
  } else {
    taskList.insertBefore(draggedItem.parentElement, after.parentElement);
  }
});

function getDragAfterElement(container, y){
  const items = [...container.querySelectorAll('.task')].filter(i=>i !== draggedItem);
  let closest = null;
  let closestOffset = Number.POSITIVE_INFINITY;
  for(const item of items){
    const box = item.getBoundingClientRect();
    const offset = Math.abs(y - (box.top + box.height/2));
    if(offset < closestOffset){
      closestOffset = offset;
      closest = item;
    }
  }
  return closest;
}

/* ======= Attach events to an item wrapper ======= */
function attachItemEvents(wrapper, item, deleteBtn){
  // HTML5 drag uses the handle, not the whole item (so user grabs handle)
  const handle = item.querySelector('.handle');

  // handle dragstart => set draggedItem and style
  handle.addEventListener('dragstart', (e) => {
    // find the .task element
    draggedItem = item;
    item.classList.add('dragging');
    try { e.dataTransfer.setData('text/plain',''); } catch (err) {}
    e.dataTransfer.effectAllowed = 'move';
  });

  handle.addEventListener('dragend', () => {
    if(draggedItem) draggedItem.classList.remove('dragging');
    draggedItem = null;
  });

  // Also support dragging via mouse on entire task for convenience
  item.addEventListener('dragstart', (e) => {
    // only set if draggedItem hasn't been set by handle
    if(!draggedItem){
      draggedItem = item;
      item.classList.add('dragging');
      try { e.dataTransfer.setData('text/plain',''); } catch (err) {}
      e.dataTransfer.effectAllowed = 'move';
    }
  });
  item.addEventListener('dragend', () => {
    if(item) item.classList.remove('dragging');
    draggedItem = null;
  });

  /* --- TOUCH reordering (pointer) when pressing handle --- */
  let touchDrag = { active:false, origin:null, lastOver:null };
  handle.addEventListener('pointerdown', (ev) => {
    if(ev.pointerType === 'mouse' && ev.button !== 0) return;
    handle.setPointerCapture(ev.pointerId);
    touchDrag.active = true;
    touchDrag.origin = wrapper;
    // visual cue
    item.classList.add('dragging');
  });
  handle.addEventListener('pointermove', (ev) => {
    if(!touchDrag.active) return;
    const el = document.elementFromPoint(ev.clientX, ev.clientY);
    const nearestLi = el ? el.closest('.task') : null;
    if(nearestLi && nearestLi !== touchDrag.lastOver && nearestLi !== item){
      touchDrag.lastOver = nearestLi;
      const items = Array.from(taskList.querySelectorAll('.task'));
      const originIndex = items.indexOf(item);
      const targetIndex = items.indexOf(nearestLi);
      if(originIndex < targetIndex){
        nearestLi.parentElement.after(item.parentElement);
      } else {
        nearestLi.parentElement.before(item.parentElement);
      }
    }
  });
  handle.addEventListener('pointerup', (ev) => {
    if(!touchDrag.active) return;
    touchDrag.active = false;
    handle.releasePointerCapture(ev.pointerId);
    item.classList.remove('dragging');
  });
  handle.addEventListener('pointercancel', (ev) => {
    if(!touchDrag.active) return;
    touchDrag.active = false;
    handle.releasePointerCapture(ev.pointerId);
    item.classList.remove('dragging');
  });

  /* --- SWIPE LEFT to reveal delete (touch) --- */
  let sw = { active:false, startX:0, startY:0, curX:0 };
  wrapper.addEventListener('touchstart', function(e){
    if(e.touches.length > 1) return;
    sw.active = true;
    sw.startX = e.touches[0].clientX;
    sw.startY = e.touches[0].clientY;
  }, {passive:true});

  wrapper.addEventListener('touchmove', function(e){
    if(!sw.active) return;
    const x = e.touches[0].clientX;
    const y = e.touches[0].clientY;
    const dx = x - sw.startX;
    const dy = y - sw.startY;
    if(Math.abs(dy) > Math.abs(dx)) return; // vertical -> ignore
    e.preventDefault();
    sw.curX = dx;
    const translate = Math.min(0, dx);
    wrapper.querySelector('.task').style.transform = `translateX(${translate}px)`;
  }, {passive:false});

  wrapper.addEventListener('touchend', function(e){
    if(!sw.active) return;
    sw.active = false;
    const threshold = -80;
    const final = sw.curX || 0;
    const taskEl = wrapper.querySelector('.task');
    if(final <= threshold){
      wrapper.classList.add('delete-show');
      taskEl.classList.add('swiped');
    } else {
      wrapper.classList.remove('delete-show');
      taskEl.classList.remove('swiped');
      taskEl.style.transform = '';
    }
    sw.curX = 0;
  });

  // prevent wrapper click from hiding delete when clicking delete btn — handled by stopPropagation on deleteBtn
  wrapper.addEventListener('click', (ev) => {
    if(wrapper.classList.contains('delete-show') && !ev.target.closest('.delete-btn')){
      // hide delete if clicking outside delete button
      wrapper.classList.remove('delete-show');
      wrapper.querySelector('.task').classList.remove('swiped');
      wrapper.querySelector('.task').style.transform = '';
    }
  });

  // Allow keyboard delete via Enter on deleteBtn
  deleteBtn.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); deleteBtn.click(); }
  });
}

/* sample tasks for testing */
['Finish maths worksheet','Study biology notes','Buy groceries'].forEach(t => { taskInput.value = t; addTask(); });
</script>
</body>
</html>
